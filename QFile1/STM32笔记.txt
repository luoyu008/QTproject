STM32笔记：
低功耗模式：
睡眠模式：关掉内核时钟即内核停止工作但是其他的外设仍但会继续工作  
优点：对系统影响小
缺点：节能效果最差

停止模式：内核时钟关闭 关闭内核逻辑电路的所有时钟 关闭外设如：IO/SPI/TIM   关闭时钟系统
优点：相对于睡眠模式节能效果较好 程序不会复位
缺点：恢复时间长

待机模式：内核时钟关闭 关闭内核逻辑电路的所有时钟 关闭外设如：IO/SPI/TIM 关时钟系统  关闭电压调节器
优点：节能效果最好
缺点：程序会进行复位 只有少数条件才会唤醒


内存类：flash是掉电不丢失的存储器ram是掉电丢失的存储区 但是ram的读取速度比flash快 所以程序中定义的变量一般会放在ram中（除了const类型的）
stm32下载程序时会下载到flash中但是定义的参数会放到ram中const类型的参数会放到flash所以当变量类型为const时会存储到flash中可以节省ram内存
栈：编译器自动分配和释放，存放函数参数，局部变量等。当函数的局部变量较多，嵌套关系复杂时，需加大栈的大小（Stack_Size）否则会导致栈溢出，程序出错甚至死机。（向下生长即第一个元素在栈区的高地址）
堆：程序员自己分配和释放，如malloc，realloc，calloc 等。（向上生长即第一个元素在堆区的低地址）

cache(高级缓存)：

外设类：
GPIO口输入时模式的选择： 看接在该引脚的外部模块的默认输出电平  若为高电平则为上拉输入 若为低电平则为下拉输入 若不确定或者外部信号输出功率很小则选择浮空输入

GPIO 	上拉输入模式下空闲时，IO呈现高电平
		浮空输入模式下空闲时，IO状态不确定，由外部环境决定
		下拉输入模式下空闲时，IO呈现低电平
		开漏输出模式下不能输出高电平必须有内部或者外部的上拉才能输出高电平
		模拟功能模式下专门用于模拟信号的输出和输入如：ADC DAC
	  	开漏复用功能模式下不能输出高电平必须有内部或者外部的上拉才能输出高电平 由其他外设控制输出
		推挽输出模式下可以输出高低电平，驱动能力强
		推挽式复用功能模式下可以输出高低电平，驱动能力强  由其他外设控制

SPI和IIC是高位先行 串口通信是低位先行

写入外设寄存器之前要先进行时钟开启  不开启的话对应的寄存器写入不了

中断函数中的尽量简短并且不要调用或使用主程序使用的函数和硬件 比如OLED函数

独立看门狗（IWDG）超时时间计算：T（IWDG）=T（LSI）*PR预分频系数*（重装寄存器（RL）+1）    T（LSI）=1/F（LSI） F(LSI)是输入时钟40khz

窗口看门狗（WWDG）超时时间（喂狗最晚时间）计算：T（WWDG）=T（PCLK1）*4096*WDGTB预分频系数（2^WDGTB）*（T【5：0】+1）
				      窗口时间（喂狗最早时间）计算：T（WIN）=T（PCLK1）*4096*WDGTB预分频系数(2^WDGTB)*（T【5：0】-W【5：0】）
					T（PCLK1）=1/F（PCLK1）  F（PCLK1）是APB1时钟即36mhz
中断：要进去NVIC，有对应的中断服务函数，需要CPU进行处理
事件：不进去NVIC，仅用于内部硬件自动控制的，如：TIM,DMA,ADC

HAL_TIM_IC_Start_IT 这个函数可开启时基单元 捕获输入 和捕获输入中断
HAL_TIM_IC_Start	这个函数可开启时基单元 捕获输入
HAL_TIM_Base_Start 这个函数可开启时基单元
若调用了的第一个则不需要调用下面两个函数 否则会重复配置出现错误

ADC的注入组可以打断规则组（先等相应的规则组转换完再打断）


底层类：
stm32启动过程（内部flash启动为例）： Rest->获取MSP值（0x08000000）[栈顶地址]+获取PC值（0x08000004）[复位向量]->Rest_Handler（复位中断函数）->启动文件（start_STM32XXX.S）->main函数

8 100
9 200
10 400
11 800
12 1000
13 2000
14 4000
15 8000